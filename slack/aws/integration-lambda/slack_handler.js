"use strict"

const querystring = require("querystring")

const SqsQueue = require("./sqs_queue")

const SlackApi = require("./slack_api")
const SlackInteraction = require("./slack_interaction")

class SlackHandler {
  constructor(application) {
    this.application = application
  }

  async handle(event, context) {
    if (event.httpMethod === "POST") {
      if (event.headers["Content-Type"] !== "application/x-www-form-urlencoded") {
        console.error("Invalid content type: %s", event.headers["Content-Type"])
        return this.#respondWithBadRequest("Content type not allowed. Use application/x-www-form-urlencoded instead.")
      }

      const slackSigningSecret = await this.application.slackSigningSecret()
      if (!slackSigningSecret) {
        return this.#respondWithUnknownError("Failed to get Slack signing secret.")
      }

      const validSignature = await SlackApi.validateSignature(
        slackSigningSecret,
        event.headers["X-Slack-Signature"],
        event.headers["X-Slack-Request-Timestamp"],
        event.body,
      )
      if (!validSignature) {
        return this.#respondWithBadRequest("Invalid signature.")
      }

      const data = querystring.decode(event.body)

      if (data.ssl_check) {
        return this.#respondSlackOk()
      }

      if (data.payload) {
        const payload = JSON.parse(data.payload)

        switch(payload.type) {
          case "view_submission": // events generated by submitting forms (views) in Slack
            return this.#handleSlackViewSubmission(payload)
          case "message_action": // events generated by performing an action on a message in Slack
            return this.#handleSlackMessageAction(payload)
          default:
            console.error("Unsupported slack payload type: %s", payload.type)
            return this.#respondWithBadRequest("Unsupported payload.")
        }
      }

      if (data.command) {
        switch(data.command) { // events generated by issuing a slash command in Slack
          case "/4me":
            return await this.#handle4meSlackCommand(data)
          default:
            console.error("Unsupported slack command: %s", data.command)
            return this.#respondWithBadRequest("Unsupported command.")
        }
      }

      console.error("Request body misses required data field 'payload' or 'command'.")
      return this.#respondWithBadRequest()
    }

    console.error("Unsupported http method: %s", event.httpMethod)
    return this.#respondWithBadRequest()
  }

  async #handleSlackViewSubmission(payload) {
    if (!payload.view) {
      console.error("No view present in slack view submission payload")
      return this.#respondWithBadRequest()
    }

    switch(payload.view.callback_id) {
      case "create-request":
        return await this.#handleCreateRequestSlackViewSubmission(payload)
      default:
        console.error("Unsupported slack view callback: %s", payload.view.callback_id)
        return this.#respondWithBadRequest()
    }
  }

  async #handleCreateRequestSlackViewSubmission(payload) {
    const slackWorkspaceId = payload.team.id
    const slackUserId = payload.user.id
    const {responseUrl} = JSON.parse(payload.view.private_metadata)
    const subject = payload.view.state.values.subject_block.subject.value
    const note = payload.view.state.values.note_block.note.value

    const result = await this.#scheduleCreateRequest(slackWorkspaceId, slackUserId, responseUrl, subject, note)

    await (new SlackInteraction(responseUrl)).send(SlackInteraction.renderScheduleCreateRequestMessage(result))

    return this.#respondSlackOk()
  }

  async #handleSlackMessageAction(payload) {
    switch(payload.callback_id) {
      case "create-request":
        return await this.#handleCreateRequestSlackMessageAction(payload)
      default:
        console.error("Unsupported slack message action callback: %s", payload.callback_id)
        return this.#respondWithBadRequest()
    }
  }

  async #handleCreateRequestSlackMessageAction(payload) {
    const responseUrl = payload.response_url
    const slackWorkspaceId = payload.team.id
    const trigger_id = payload.trigger_id
    const subject = null
    const note = payload.message.text

    return await this.#handleRequestSlack(responseUrl, slackWorkspaceId, trigger_id, subject, note)
  }

  async #handle4meSlackCommand(data) {
    const responseUrl = data.response_url
    const slackWorkspaceId = data.team_id
    const text = data.text
    const trigger_id = data.trigger_id

    const [match, subCommand, payload] = text.match(/([^\s]*)(?:\s(.*))?/)

    switch(subCommand) {
      case "help":
        return await this.#respondWith4meHelpResponse()
      case "request":
        const subject = payload
        const note = null
        return await this.#handleRequestSlack(responseUrl, slackWorkspaceId, trigger_id, subject, note)
      default:
        return await this.#handleRequestSlackCommand(data)
    }
  }

  async #handleRequestSlackCommand(data) {
    const responseUrl = data.response_url
    const slackWorkspaceId = data.team_id
    const subject = data.text
    const trigger_id = data.trigger_id
    const note = null

    return await this.#handleRequestSlack(responseUrl, slackWorkspaceId, trigger_id, subject, note)
  }

  async #scheduleCreateRequest(slackWorkspaceId, slackUserId, responseUrl, subject, note) {
    return await (new SqsQueue(this.application.sqsQueueUrl)).sendMessage(
      JSON.stringify({slackWorkspaceId, slackUserId, responseUrl, subject, note}),
    )
  }

  async #handleRequestSlack(responseUrl, slackWorkspaceId, trigger_id, subject, note) {
    const createRequestView = SlackInteraction.createRequestView(responseUrl, subject, note)

    const providerFourMe = await this.application.providerFourMe()
    if (!providerFourMe) {
      return this.#respondSlackError("Failed to connect to 4me.")
    }

    const appInstance = await providerFourMe.activeAppInstance(this.application.offeringReference, {slackWorkspaceId})
    if (!appInstance) {
      return this.#respondSlackError("Your Slack workspace is not connected to 4me.")
    }

    const slackApi = await this.application.slackApi(appInstance.account)
    if (!slackApi) {
      return this.#respondSlackError("Failed to connect to slack Api.")
    }

    const result = await slackApi.openModal(trigger_id, createRequestView)
    if (!result) {
      return this.#respondSlackError("Failed to open Slack modal.")
    }

    return this.#respondSlackOk()
  }

  #respondWith4meHelpResponse() {
    return {
      "statusCode": 200,
      "body": JSON.stringify({
        "response_type": "in_channel",
        "text": this.#render4meHelp(),
      })
    }
  }

  #render4meHelp() {
    return "Usage: /4me [request subject]"
  }

  #respondWithBadRequest(message) {
    this.#error(message)
    return this.#respondWith(message, 400)
  }

  #respondWithUnknownError(message) {
    this.#error(message)
    return this.#respondWith(message, 500)
  }

  #respondWith(message, code = 200) {
    return {
      "statusCode": code,
      "body": JSON.stringify({message}),
    }
  }

  #error(message, ...data) {
    if (data && data.length > 0) {
      console.error(message, ...data);
    } else {
      console.error(message);
    }
  }

  #respondSlackOk() {
    return {
      "statusCode": 200,
    }
  }

  #respondSlackError(text) {
    console.error(text)

    return {
      "statusCode": 200,
      "body": JSON.stringify({
        "response_type": "in_channel",
        ...SlackInteraction.renderSlackErrorMessage(text),
      }),
    }
  }
}

module.exports = SlackHandler
